using Libdl, Random

"""
    TaylorGenerator(name=randstring(12), eqs_filename, parent_path=".")

Structure used to generate directories and call taylor. The directory name will
be `\$(parent_path)/taylor_\$(name)`. The equation file should follow the syntax
required by taylor.
"""
@kwdef mutable struct TaylorGenerator
    name::String = randstring(12)
    eqs_filename::String
    parent_path::String = "."
end

"""
    TaylorHandler(path)

Structure used to open, use and close directories generated by `TaylorGenerator`.
"""
@kwdef mutable struct TaylorHandler
    # name::String = randstring(12)
    #filename::String
    path::String# = "."
    symbols::Dict{String, Ptr{Nothing}} = Dict{String, Ptr{Nothing}}()
    lib::Union{Nothing, Ptr{Nothing}} = nothing
end

"""
    get_dir_src()

Returns the directory containing this package.
"""
function get_dir_src()
    return dirname(pathof(TaylorInterface))
end

"""
    get_models_dir()

Returns the directory containing predefined models.
"""
function get_models_dir()
    return joinpath(get_dir_src(), "models")
end

"""
    get_taylor_dir(generator)

Returns the directory associated to the generator.
"""
function get_taylor_dir(gen::TaylorGenerator)
    return joinpath(gen.parent_path, "taylor_$(gen.name)")
end

"""
    get_handler(generator, open=true)

Get the `TaylorHandler` corresponding to the generator. If `open` is true,
the library will also be open in the handler.
"""
function get_handler(gen::TaylorGenerator, open::Bool=true)
    handler = TaylorHandler(path=get_taylor_dir(gen))
    if open
        open_lib(handler)
    end
    return handler
end

"""
    get_model(name, open=false)

Get the `TaylorHandler` corresponding to a default model in this package. If
`open` is true, the library will also be open in the handler.

Warning: `name` should NOT contain the prefix "taylor_h".
"""
function get_model(name::String, open::Bool=false)
    fullname = "taylor_$(name)"
    dirname = joinpath(get_models_dir(), fullname)
    if isdir(dirname)
        handler = TaylorHandler(
            path = dirname,
        )
        if open
            return open_lib(handler)
        else
            return handler
        end
    else
        error("No model found")
    end
end

"""
    get_jet_flag(generator)

Get the jet flag to pass to taylor when compiling the equations given by the
generator.
"""
function get_jet_flag(gen::TaylorGenerator)
    flag = ""
    open(gen.eqs_filename, "r") do file
        for line in eachline(file)
            if length(line) > 5 && line[1:4] == "jet "
                splitline = split(line[1:end-1])
                #println(findfirst(x->x=="symbols", splitline))
                #println(findfirst(x->x=="degree", splitline))
                nsymbols = parse(Int,
                    splitline[findfirst(x->x=="symbols", splitline)+1])
                degree = parse(Int,
                    splitline[findfirst(x->(x=="degree" || x=="deg"), splitline)+1])
                if nsymbols == 1
                    flag = "-jlib jet1"
                elseif degree == 1
                    flag = "-jlib jet_1"
                end
            end
        end
    end 
    return flag
end

"""
    get_wrappers(generator)

Get the appropriate wrapper files for the generator.
"""
function get_wrappers(gen::TaylorGenerator)
    jet_flag = get_jet_flag(gen)
    if jet_flag == ""
        return "original_wrappers/wrapper_nojet.c", "original_wrappers/wrapper_nojet.h"
    else
        return "original_wrappers/wrapper.c", "original_wrappers/wrapper.h"
    end
end

"""
    generate_dir(generator)

Generates the directory corresponding to the generator, and builds the library.
"""
function generate_dir(gen::TaylorGenerator)
    name = gen.name
    dir = get_taylor_dir(gen)
    curr_dir = pwd()
    jet_flag = get_jet_flag(gen)
    wrapper_c, wrapper_h = get_wrappers(gen)
    if isdir(dir)
        @warn "$(dir) already exists. Cleaning..."
        clear_dir(gen)
    end
    run(`mkdir $(dir)`)
    run(`cp $(gen.eqs_filename) $(dir)`)
    cd(dir)
    try
        run(`mkdir src`)

        true_eqs_filename = split(gen.eqs_filename, '/')[end]
        
        # GENERATE MAKEFILE
        prefix="""CC=gcc
        CFLAGS=-O2 -fPIC -Wno-unused-result
        CFLAGSSO=-shared
        LFLAGS=-lm
        TAYLOR=taylor"""
        makefile_text = """
        $(prefix)
        all: lib.so
        
        lib.so: src/wrapper-$(name).o src/taylor-$(name).o
        \t\$(CC) \$(CFLAGS) \$(CFLAGSSO) src/wrapper-$(name).o src/taylor-$(name).o -o lib.so \$(LFLAGS)

        src/wrapper-$(name).o: src/wrapper-$(name).c src/wrapper-$(name).h src/taylor-$(name).c src/taylor-$(name).h
        \t\$(CC) \$(CFLAGS) -c src/wrapper-$(name).c -o src/wrapper-$(name).o

        src/taylor-$(name).o: src/taylor-$(name).c src/taylor-$(name).h
        \t\$(CC) \$(CFLAGS) -c src/taylor-$(name).c -o src/taylor-$(name).o \$(LFLAGS)

        src/taylor-$(name).c: $(true_eqs_filename)
        \t\$(TAYLOR) -name auto -headername taylor-$(name).h -o src/taylor-$(name).c -jet -step $(jet_flag) -jet_helper $(true_eqs_filename)

        src/taylor-$(name).h: $(true_eqs_filename)
        \t\$(TAYLOR) -name auto -o src/taylor-$(name).h $(jet_flag) -header $(true_eqs_filename)

        clean:
        \trm lib.so src/taylor-* src/*.o
        """

        open("Makefile", "w") do makefile
            write(makefile, makefile_text)
        end
        
        # GENERATE WRAPPERS
        open(joinpath(get_dir_src(), wrapper_c), "r") do cwrap
            cwraptext = read(cwrap, String)
            open("src/wrapper-$(name).c", "w") do cwrap
                write(cwrap, "#include \"wrapper-$(name).h\"\n")
                write(cwrap, cwraptext)
            end
        end
        open(joinpath(get_dir_src(), wrapper_h), "r") do hwrap
            hwraptext = read(hwrap, String)
            open("src/wrapper-$(name).h", "w") do hwrap
                write(hwrap, """
                #ifndef WRAPPER_$(name)_H
                #define WRAPPER_$(name)_H
        
                #include "taylor-$(name).h"\n
                """)
                write(hwrap, hwraptext)
            end    
        end
    finally
        cd(curr_dir)
    end

    # RUN MAKEFILE
    compile_eqs(gen)
    return
end

"""
    compile_eqs(generator)

Runs `make` in the directory of the generator.
"""
function compile_eqs(gen::TaylorGenerator)
    dir = get_taylor_dir(gen)
    curr_dir = pwd()
    cd(dir)
    try
        run(`make`)
    finally
        cd(curr_dir)
    end
    return
end

"""
    compile_eqs(handler)

Runs `make` in the directory of the handler.
"""
function compile_eqs(handler::TaylorHandler)
    dir = handler.path
    curr_dir = pwd()
    cd(dir)
    try
        run(`make`)
    finally
        cd(curr_dir)
    end
    return
end

"""
    open_lib(handler)

Opens the handler's library, storing the loaded library and a dictionary with
symbols to functions in the handler.

Currently, the loaded functions are `flow`, `tstep` and `tstep_reverse`.
"""
function open_lib(handler::TaylorHandler)
    lib = Libdl.dlopen(joinpath(handler.path, "lib.so"))
    dict = Dict{String, Ptr{Nothing}}()
    for func in ["flow", "tstep", "tstep_reverse"]
        dict[func] = Libdl.dlsym(lib, Symbol(func))
    end
    handler.symbols = dict
    handler.lib = lib
    return handler
end

"""
    is_open(handler)

Check if handler refers to an open library.
"""
function is_open(handler::TaylorHandler)
    return !(handler.lib === nothing)
end

"""
    check_open(handler)

Check if handler refers to an open library, and opens it if not.
"""
function check_open(handler::TaylorHandler)
    if !is_open(handler)
        open_lib(handler)
    end
end

"""
    close_lib(handler)

Close the library referred by the handler.
"""
function close_lib(handler::TaylorHandler)
    if is_open(handler)
        Libdl.dlclose(handler.lib)
        handler.lib = nothing
    end
    handler.symbols = Dict{String, Ptr{Nothing}}()
    return handler
end

"""
    clear_dir(handler)

Delete the directory referred by the handler.
"""
function clear_dir(handler::TaylorHandler)
    close_lib(handler)
    run(`rm -rf $(handler.path)`)
    return
end

"""
    clear_dir(generator)

Delete the directory referred by the generator.
"""
function clear_dir(gen::TaylorGenerator)
    run(`rm -rf $(get_taylor_dir(gen))`)
    return
end